// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

//#############################################
//
// sciloop : reason for overwrite :
// support for driven keys with animLayers.
//
if( exists( "sciSetDrivenKeyWindowAdditions" ) )
{source "sciSetDrivenKeyWindowAdditions.mel";}


//#############################################
//

// Creation Date:  9 February 1997
//
//
//  Procedure Name:
//      setDrivenKeyWindow
//
//  Description:
//              Creates a window to allow the user
//              to set "driven keyframes" against
//              channels - IE: one channel is used
//              to drive another channel, rather than
//              having time drive the value changes.
//
//  Input Arguments:
//      None.
//
//  Return Value:
//      None.
//

// globals used to so that we can key against the flexor guide
// but display the guide joint rather than the guide name
//
global int $driversAreGuides;
global string $guideDrivers[];

global proc string setDrivenKeyNothingSelected()
{
	return (uiRes("m_setDrivenKeyWindow.kNothingSelected"));
}


// Fiven a string return the name that will be used as the
// item to be keyed in the setDrivenKeyframe command.
//
// This is needed because the $object may be a plug
// on a node, a component on a shape or simply a node.
//
global proc string getNodeName(string $object)
{
	string $result;
	string $buffer[3];
	$numTokens = tokenize($object,".",$buffer);
	if ($numTokens > 1) {
		string $isAnEntity[] = `ls -type entity $buffer[0]`;
		if (size($isAnEntity)) {
			$result = $object;
		} else {
			$result = $buffer[0];
		}
	}
	else {
		$result = $object;
	}
	return $result;
}

proc updateLongNamesFromUI( string $channelListLong, string $channelListUI )
//
// Description:
//		The window presents the UI-version of the channel names: long, short,
//		nice depending on the optionVar.  But all the commands generated by
//		this window need to use longNames in them.  So, before querying the
//		longName textScrollLists for the info required to generate the right
// 		commands, we'll synchronize the selected longName attrs with those
// 		already selected in the uiName list.
//
{
	int     $selectedAttrs[] = `textScrollList -q -selectIndexedItem $channelListUI`;
	int     $selected;

	textScrollList -e -deselectAll $channelListLong;
	for( $selected in $selectedAttrs ) {
		textScrollList -e -selectIndexedItem $selected $channelListLong;
	}
}

proc updateUINamesFromLong( string $objectList, string $channelListLong, string $channelListUI)
//
// Description:
//	 Now that the longName list is determined, we can update
//	 the niceName list from the contents of the longName list.
//
{
	string $objects[] = `textScrollList -query -selectItem $objectList`;
	if( size( $objects ) == 0 ) {
		return;
	}

	string  $longAttrs[] = `textScrollList -q -allItems $channelListLong`;
	string  $long;
	int     $selectedAttrs[] = `textScrollList -q -selectIndexedItem $channelListLong`;
	int     $selected;

	textScrollList -e -removeAll $channelListUI;
	for( $long in $longAttrs ) {
		textScrollList -e -append (channelNameSDK( $objects[0], $long )) $channelListUI;
	}

	textScrollList -e -deselectAll $channelListUI;
	for( $selected in $selectedAttrs ) {
		textScrollList -e -selectIndexedItem $selected $channelListUI;
	}
}

global proc goToDrivenKeyCallback(string $advanceFlag)
//
//	Description:
//		If a driven attribute is selected, use it as the
//		attribute to be advanced to the next/previous frame.
//
{
	updateLongNamesFromUI( "driverChannelsLong", "driverChannelsUI" );
	updateLongNamesFromUI( "drivenChannelsLong", "drivenChannelsUI" );

	string $cmd = ("advanceToNextDrivenKey "+$advanceFlag+" ");

	// Get a driven object, and one or more selected channels
	// for the driven object
	//
	string $driven[] = `textScrollList -query -selectItem drivenObjects`;
	string $drivenChannel[] = `textScrollList -query -selectItem drivenChannelsLong`;
	if (1 == size($drivenChannel) && 1 == size($driven)) {
		string $drivenNode = getNodeName($driven[0]);

		$cmd += ($drivenNode+"."+$drivenChannel[0]);
	} else {
		// The "" tells the advanceToNextDrivenKey script that
		// it will operate on the selection list
		//
		$cmd += ("\"\"");
	}

	// evaluate the advanceToNextDrivenKey command
	//
	eval($cmd+"\n");
}

// If string $str is in list $list, returns a non-zero number
// indicating the *1*-based index into the array.
//
global proc int isStringInList(string $str, string $list[])
{
	int $ii;
	int $listSize = size($list);

	for ($ii = 0; $ii < $listSize; $ii++) {
		if ($list[$ii] == $str) {
			return ($ii+1);
		}
	}
	return 0;
}

// Special method used here to clear duplicate entries from the
// list $list
//
global proc removeDuplicateStringsInList(string $list[])
{
	int $ii, $jj;
	int $listSize = size($list);

	for ($ii = 0; $ii < ($listSize-1); $ii++) {
		string $checkString = $list[$ii];

		if ($checkString == "") {
			continue;
		}

		for ($jj = $ii+1; $jj < $listSize; $jj++) {
			if ($list[$jj] == $checkString) {
				$list[$jj] = "";
			}
		}
	}
}

// given a plug name $object, strip out the $attrName
//
//
global proc string[] sdkGetAttr(string $object)
{
	string $result[1];

	string $attrName = "";
	string $buffer[3];
	$numTokens = tokenize($object,".",$buffer);
	if ($numTokens > 1) {
		int $ii;
		for ($ii = 1; $ii < $numTokens; $ii++) {
			if ($ii != 1) {
				$attrName += ".";
			}
			$attrName += $buffer[$ii];
		}
	}
	$result[0] = $attrName;
	return $result;
}

// Return a mel command appropriate for the given object.
// If $driver is true, consider nonkeyable attributes in addition
// to keyable.
//
global proc string genListAttrString(int $driver,string $object) {

	string $cmd;

	string $buffer[3];
	$numTokens = tokenize($object,".",$buffer);
	string $isAnEntity[] = `ls -type entity $buffer[0]`;
	if ($numTokens > 1 && (0 == size($isAnEntity))) {
		// If the object name has embedded .'s and the $object type
		// is not an entity, the assumption here is that the $object
		// is a plug rather than a component on a shape.
		//
		// In this case we take the attribute name directly from the plug
		// since a listAttr command would list all the attributes instead of
		// only the selected attribute
		//
		$cmd = "sdkGetAttr ";
	}
	else {
		$cmd = "listAttr -scalarAndArray -visible -connectable -unlocked -multi -leaf ";

		// only show the keyable attributes unless the showNonKeyable
		// option is true
		//
		int $showNonKeyable = `optionVar -query SDKshowNonKeyable`;

		if ($driver == 0 && ! $showNonKeyable) {
			$cmd += "-keyable ";
		}

		// because there are so many attributes on transforms, we only
		// list the keyable attributes for them when listing the driver
		//
		string $xforms[] = `ls -type transform $object`;
		if ($driver && size($xforms)) {
			$cmd += "-keyable ";
		}
	}

	$cmd += $object;
	return $cmd;
}


global proc generateSetDrivenCommand( )
//
//      Generate a setDrivenKeyframe command for
//      each of the selected channels in the driven channel
//      text scroll list.
{
	global int $driversAreGuides;
	global string $guideDrivers[];

	updateLongNamesFromUI( "driverChannelsLong", "driverChannelsUI" );
	updateLongNamesFromUI( "drivenChannelsLong", "drivenChannelsUI" );

	// Get a driver, and the selected channel for the driver
	//
	string $driver[] = `textScrollList -query -selectItem driverObjects`;
	string $driverChannel[] = `textScrollList -query -selectItem driverChannelsLong`;
	// Get a driven object, and one or more selected channels
	// for the driven object
	//
	string $driven[] = `textScrollList -query -selectItem drivenObjects`;
	string $drivenChannel[] = `textScrollList -query -selectItem drivenChannelsLong`;
	string $cmd;

	if (0 == size($driver)
	||  0 == size($driverChannel)) {
		error( (uiRes("m_setDrivenKeyWindow.kMustSelectNode")) );
		return;
	}

	if (0 == size($driven)
	||  0 == size($drivenChannel)) {
		error( (uiRes("m_setDrivenKeyWindow.kMustSelectNodeDriven")) );
	}

	int $i, $j, $which;
	for ( $i=0; $i < size( $driven ); $i++ ) {

		string $drivenNode = getNodeName($driven[$i]);

		for( $j=0; $j < size( $drivenChannel ); $j++ )
		{
			$cmd = "setDrivenKeyframe -currentDriver ";

			if ($driversAreGuides) {
				// if a guide node is in the driver list, key against the
				// driver node rather than the joint
				//
				string $guides[] = `textScrollList -query -allItems driverObjects`;
				$which = isStringInList($driver[0],$guides) - 1;
				$cmd = ( $cmd +
						 $guideDrivers[$which] + "." +
						 $driverChannel[0] + " " );
			} else {
				$cmd = ( $cmd + $driver[0] + "." + $driverChannel[0] + " " );
			}


//##########################################################################################
//
// sciloop
//
            //$cmd = ( $cmd + $drivenNode + "." + $drivenChannel[$j] );

            $cmd = sciCreateCommandForSetDrivenKeyWindow(   $cmd,
                                                            $drivenNode,
                                                            $drivenChannel[$i] );

//#########################################################################################

			//
			// Evaluate and echo the command for the users benefit
			//
			evalEcho( $cmd );
		}
	}
}

global proc selectDriven( )
//
//      callback used to select all driven objects
//
{
	string $driven[] = `textScrollList -query -selectItem drivenObjects`;

	if (size($driven) && $driven[0] != (setDrivenKeyNothingSelected())) {
		select -replace $driven;
	}
}

global proc updateKeyButton( )
//
//      Called any time that selection are made in the
//      driver and driven channels textScrollLists, in order
//      to update the state of the "Key" button.  The user
//      must select: a driver object, a driven object, and
//      channels for both driver and driven before the "Key"
//      button is enabled.
{
	if( `textScrollList -query -numberOfSelectedItems driverChannelsUI` != 0
	&&  `textScrollList -query -numberOfSelectedItems drivenChannelsUI` != 0 )
	{
		button -edit -enable true keyButton;
	} else {
		button -edit -enable false keyButton;
	}
}

global proc updateChannels( string $list,
							string $channelListLong,
							string $channelListUI )
//
//      Called whenever a new object is selected in
//      either the driver or driven object textScrollList's,
//      in order to fill the corresponding channel list
//      with a list of keyable channels for the driver or
//      driven objects.
{
	global int $driversAreGuides;
	global string $guideDrivers[];

	int $driver = ($list == "driverObjects");

	string $currChannels[] = `textScrollList -query -selectItem $channelListLong`;
	string $object[] = `textScrollList -query -selectItem $list`;

	if ($list == "driverObjects" && $driversAreGuides) {
		int $which;
		string $allObjects[] = `textScrollList -query -allItems $list`;
		$which = isStringInList($object[0],$allObjects) - 1;

		if ($which > -1)
			$object[0] = $guideDrivers[$which];
	}

	string $listAttrCmd = genListAttrString($driver,
											$object[0]);

	string $attrs[] = eval( $listAttrCmd );
	removeDuplicateStringsInList($attrs);
	textScrollList -edit -removeAll $channelListLong;

	int $ii, $jj;
	int $attrCount = size($attrs);
	for ($ii = 1; $ii < size($object); $ii++) {
		$listAttrCmd = genListAttrString($driver,
										 $object[$ii]);

		string $attrs2[] = eval( $listAttrCmd );
		for ($jj = 0; $jj < $attrCount; $jj++) {
			if ($attrs[$jj] == "") { continue; }
			if (! isStringInList($attrs[$jj],$attrs2)) {
				$attrs[$jj] = "";
			}
		}
	}

	int $selectChannels = 0;
	string $selChannels = "textScrollList -edit ";
	for( $item in $attrs )
	{
		if ($item != "") {
			if (isStringInList($item,$currChannels)) {
				$selectChannels = 1;
				$selChannels += "-selectItem "+$item+" ";
			}
			textScrollList -edit -append $item $channelListLong;
		}
	}

	if ($selectChannels) {
		$selChannels += $channelListLong;
		eval($selChannels);
	}

	updateUINamesFromLong( $list, $channelListLong, $channelListUI );
}


global proc loadCurrentDriver()
//
// Query the currently selected driven object and if it has
// any drivers, load them in the driver lists.
//
{
	global int $driversAreGuides = 0;
	global string $guideDrivers[];

	string $driverNodes[];
	string $currentNode;
	string $currentAttr;
	string $objects[] = `textScrollList -query -selectItem drivenObjects`;
	string $attrs[] = `textScrollList -query -selectItem drivenChannelsLong`;

	string $noDrivers = uiRes( "s_TsetDrivenKeyframeCmdStrings.rSetDrivenNoDrivers" );
	textScrollList -edit -removeAll driverObjects;
	textScrollList -edit -removeAll driverChannelsLong;
	textScrollList -edit -removeAll driverChannelsUI;
	if (size($objects)
		&& ($objects[0] != (setDrivenKeyNothingSelected())) ) {
		string $queryString = "setDrivenKeyframe -query -driver "+$objects[0];
		string $currentString = "setDrivenKeyframe -query -currentDriver "+$objects[0];
		if (size($attrs)) {
			$queryString += "."+$attrs[0];
			$currentString += "."+$attrs[0];
		}

		string $current[] = eval($currentString);
		string $drivers[] = eval($queryString);
		if ( size($drivers) &&
			 ($drivers[0] == $noDrivers ||
			  $drivers[0] == "") )
		{
			$drivers = `setDrivenKeyframe -query -driver ($objects[0])`;
			$current = `setDrivenKeyframe -query -currentDriver ($objects[0])`;
		}

		string $buffer[];
		// tokenize the result into nodes and attrs
		//
		if ($current[0] != $noDrivers) {
			if (2 == tokenize($current[0], ".", $buffer))
			{
				$currentNode = $buffer[0];
				$currentAttr = $buffer[1];
			}
		}

		int $ii;
		int $counter = 0;
		clear $guideDrivers;
		for ($ii = 0; $ii < size($drivers); $ii++)
		{
			if ($drivers[$ii] != $noDrivers && $drivers[$ii] != "")
			{
				if (2 == tokenize($drivers[$ii], ".", $buffer))
				{
					string $cds[] = `textScrollList -query -allItems driverObjects`;

					string $nameToUse;
					if (nodeType($buffer[0]) == "guide") {
						string $sArr[];
						$sArr = `listConnections -destination false ($buffer[0]+".jointXformMatrix")`;

						if (0 != size($sArr)) {
							$driversAreGuides = 1;
							$nameToUse = $sArr[0];

							if ($buffer[0] == $currentNode) {
								$currentNode = $nameToUse;

							}
						} else {
							$nameToUse = $buffer[0];
						}
					} else {
						$nameToUse = $buffer[0];
					}

					if (! isStringInList($nameToUse,$cds) ) {

						textScrollList -edit -append $nameToUse driverObjects;
						$guideDrivers[$counter] = $buffer[0];
						$counter++;

					}
				}
			}
		}

		if ($currentNode != "") {
			string $currentNiceAttr = channelNameSDK( $currentNode, $currentAttr );
			textScrollList -edit -selectItem $currentNode driverObjects;
			updateChannels driverObjects driverChannelsLong driverChannelsUI;
			textScrollList -edit -selectItem $currentAttr driverChannelsLong;
			textScrollList -edit -selectItem $currentNiceAttr driverChannelsUI;
			textScrollList -edit -enable true driverObjects;
		}
	}
}

global proc selectListItems(string $list)
//
//      Called whenever a new object is selected in
//      the driven object textScrollList.
//      If the select driven checkbox is selected, selects
//      the current driven item.
//
{

	if (`optionVar -query SDKselectListItems`) {
		string $objects[] = `textScrollList -query -selectItem $list`;
		if (size($objects)
		&& ($objects[0] != (setDrivenKeyNothingSelected())) ) {
			select -replace $objects;
		}
	}
}

proc fillObjectList( string $list, string $node, string $attr[])
//
//      Called by the updateSetDrivenWnd proc, in
//      order to fill the textScrollLists with a list
//      of available objects for each.
//
//      If $node and $attr are not empty, these items are used as the
//      driven items. Else if they are empty, the selection list is used
//      to fill the specified text scroll list.
//
//      If nothing is selected when the user performs this operation,
//      the textScrollList is disabled, and the string
//      setDrivenKeyNothingSelected() is put into the list.
//
{
	global int $driversAreGuides;
	global string $guideDrivers[];

	// find current selection list
	//
	string $objects[20];
	if (! (`optionVar -query SDKshowShapes`)) {
		$objects = `ls -selection`;
	} else {
		$objects = `listRelatives -shapes`;
	}

	// determine whether current list should be cleared
	//
	int $selectedSomething = 0;
	string $currObjects[] = `textScrollList -query -allItems $list`;
	if (`optionVar -query SDKclearOnLoad`) {
		textScrollList -edit -removeAll $list;
		if ($list == "driverObjects")
			$driversAreGuides = 0;
	} else if (1 == `textScrollList -query -numberOfItems $list`
		   &&  (setDrivenKeyNothingSelected()) == $currObjects[0]) {
		textScrollList -edit -removeAll $list;
		if ($list == "driverObjects")
			$driversAreGuides = 0;
	} else {
		textScrollList -edit -deselectAll $list;
	}

	// find current contents of textScrollList
	//
	$currObjects = `textScrollList -query -allItems $list`;

	int $counter = size($guideDrivers);

	// fill list
	//
	if ( $node == "" ) {
		if( `size( $objects )` == 0 )
			//      Nothing selected - disable the control,
			//      and put in a string that informs the user
			//      that they have nothing selected to load
			//      into the textScrollList
		{
			textScrollList -edit -removeAll $list;
			textScrollList -edit -append (setDrivenKeyNothingSelected()) $list;
			textScrollList -edit -enable false $list;
			button -edit -enable false keyButton;
			return;
		}

		for( $item in $objects )
		{
			textScrollList -edit -enable true $list;
			if (! isStringInList($item,$currObjects)) {
				textScrollList -edit -append $item $list;
				$guideDrivers[$counter] = $item;
				$counter++;
			}
		}
		int $listCount = `textScrollList -query -numberOfItems $list`;
		if (1 == $listCount || size($attr) > 0) {
			for ($ii = 0; $ii < $listCount; $ii++) {
				textScrollList -edit -selectIndexedItem ($ii+1) $list;
				$selectedSomething = 1;
			}
		}
	} else {
		textScrollList -edit -append $node $list;
		int $listSize = `textScrollList -query -numberOfItems $list`;
		textScrollList -edit -selectIndexedItem $listSize $list;
		$selectedSomething = 1;
	}

	if ($selectedSomething == 1) {
		if ($list == "drivenObjects") {
			updateChannels drivenObjects drivenChannelsLong drivenChannelsUI;

			if (size($attr) > 0 && $attr[0] != "") {
				for ($attribute in $attr) {
					// $attr might be the name of a compound.  If so, get something
					// we're actually listing in the
					string $listAttrCmd =
						genListAttrString( 0, "" ) + ($node+"."+$attribute);

					string $resultAttrs[] = eval( $listAttrCmd );

					// The listAttr cmd will return long names.  Select the result
					// in the longName textScrollList, then update the niceName textScrollList
					// accordingly.
					//
					if( size( $resultAttrs ) > 0 ) {
						textScrollList -edit -selectItem $resultAttrs[0] drivenChannelsLong;
						updateUINamesFromLong( $list, "drivenChannelsLong", "drivenChannelsUI" );
					}
				}
			}
		} else {
			updateChannels driverObjects driverChannelsLong driverChannelsUI;
		}
	}
}




global proc updateSetDrivenWnd( string $which, string $node, string $attr[] )
//
//  Called whenever the user clicks on either the
//  "Load Driver" or "Load Driven" buttons.  This
//  proc will fill the driver and driven object
//  lists.
{
    switch( $which ) {
        case "driver":
            textScrollList -edit -removeAll driverChannelsLong;
            textScrollList -edit -removeAll driverChannelsUI;
            fillObjectList("driverObjects","",{});
            button -edit -enable false keyButton;
            break;
        case "driven":
			textScrollList -edit -removeAll drivenChannelsLong;
			textScrollList -edit -removeAll drivenChannelsUI;
			fillObjectList("drivenObjects",$node,$attr);
			button -edit -enable false keyButton;
            break;
    }
}

global proc buildSetDrivenKeyContextHelpItems(string $nameRoot, string $menuParent)
{
	menuItem -label (uiRes("m_setDrivenKeyWindow.kHelpSDK"))
		-enableCommandRepeat false
		-command "showHelp SetDrivenKey";
}

proc int channelNameStyle() {
	if( !`optionVar -exists SDKchannelNames` ) {
		optionVar -intValue SDKchannelNames 2;
	}

	return `optionVar -q SDKchannelNames`;
}

global proc refreshChannelsSDK() {
	updateUINamesFromLong( "driverObjects", "driverChannelsLong", "driverChannelsUI" );
	updateUINamesFromLong( "drivenObjects", "drivenChannelsLong", "drivenChannelsUI" );
}

global proc string channelNameSDK( string $node, string $attr ) {
	string $result = $attr;
	string $plug = ( $node + "." + $attr );

	// With this workaround for bug 301890, we'll still generate
	// error messages when the user chooses a leaf-only name of
	// a child of a multi, but at least displaying the window won't
	// choke on calling attributeName on a $plug that doesn't
	// really exist.
	//
	int $useWorkaround = ( size( `ls $plug` ) == 0 );
	switch( `channelNameStyle` ) {
		case 0:
			if( $useWorkaround ) {
				$result = `attributeQuery -node $node -shortName $attr`;
			} else {
				$result = `attributeName -short $plug`;
			}
			break;
		case 1:
			if( $useWorkaround ) {
				$result = `attributeQuery -node $node -longName $attr`;
			} else {
				$result = $attr;
			}
			break;
		case 2:
			if( $useWorkaround ) {
				$result = `attributeQuery -node $node -niceName $attr`;
			} else {
				$result = `attributeName -nice $plug`;
			}
			break;
		default:
			$result = $attr;
			break;
	}

	return $result;
}

proc createSetDrivenWnd()
//
//      Creates the setDriveKeyframe window, with
//      four textScrollLists, one for each of the driver
//      and driven objects, and their channels.
//
//      Also creates a "Key" button to key the currently
//      selected items, "Load Driver" and "Load Driven"
//      buttons to load the selected objects into the
//      driver and driven lists, and a "Close" button,
//      to allow the user to close the window without
//      having to double click on the close box.
//
//      If the window already exists, then the proc
//      simply shows the window, effectively popping it
//      to the top, if it's under other windows.
{
	window -title (uiRes("m_setDrivenKeyWindow.kSetDrivenKey"))
		-retain
		-iconName (uiRes("m_setDrivenKeyWindow.kSetDriven"))  -menuBar true
		-sizeable true -widthHeight 390 530 setDrivenWnd;

	menu -label (uiRes("m_setDrivenKeyWindow.kLoad"))  -tearOff true;
	menuItem -label (uiRes("m_setDrivenKeyWindow.kSelectedAsDriver"))
		-command "updateSetDrivenWnd(\"driver\",\"\",{})";
	menuItem -label (uiRes("m_setDrivenKeyWindow.kSelectedAsDriven"))
		-command "updateSetDrivenWnd(\"driven\",\"\",{})";
	menuItem -label (uiRes("m_setDrivenKeyWindow.kCurrentDriver"))
		-command "loadCurrentDriver";
	setParent -menu ..;

	optionVar -intValue SDKclearOnLoad 1;
	optionVar -intValue SDKshowShapes 0;
	optionVar -intValue SDKselectListItems 1;
	optionVar -intValue SDKshowNonKeyable 0;

 	menu -label (uiRes("m_setDrivenKeyWindow.kOptions"))  -tearOff true;
		int $channelNames = channelNameStyle();
		menuItem -label (uiRes("m_setDrivenKeyWindow.kChannelNames"))  -subMenu 1;
			string $collection = `radioMenuItemCollection setDrivenChannelNamesCollection`;
			menuItem -label (uiRes("m_setDrivenKeyWindow.kNice"))
				-collection $collection
				-command "optionVar -intValue SDKchannelNames 2; refreshChannelsSDK"
				-radioButton ($channelNames == 2);
			menuItem -label (uiRes("m_setDrivenKeyWindow.kLong"))
				-collection $collection
				-command "optionVar -intValue SDKchannelNames 1; refreshChannelsSDK"
				-radioButton ($channelNames == 1);
			menuItem -label (uiRes("m_setDrivenKeyWindow.kShort"))
				-collection $collection
				-command "optionVar -intValue SDKchannelNames 0; refreshChannelsSDK"
				-radioButton ($channelNames == 0);
			setParent -menu ..;

	 	menuItem -label (uiRes("m_setDrivenKeyWindow.kClearOnLoad"))  -checkBox 1
			-command ("optionVar -intValue SDKclearOnLoad #1;");
	 	menuItem -label (uiRes("m_setDrivenKeyWindow.kLoadShapes"))  -checkBox 0
			-command ("optionVar -intValue SDKshowShapes #1;");
		menuItem -label (uiRes("m_setDrivenKeyWindow.kAutoSelect"))  -checkBox 1
			-command ("optionVar -intValue SDKselectListItems #1;");
		menuItem -label (uiRes("m_setDrivenKeyWindow.kListKeyableDrivenAttrs"))  -checkBox 1
			-command ("optionVar -intValue SDKshowNonKeyable (!(#1)); updateChannels drivenObjects drivenChannelsLong drivenChannelsUI");
		setParent -menu ..;

	// Mimic the Set Driven Key portion of the Key menu in AniKeyframeMenu.mel
    //
	menu -label (uiRes("m_setDrivenKeyWindow.kKey"))  -tearOff true;

    menuItem -label (uiRes("m_setDrivenKeyWindow.kSet"))  -command "generateSetDrivenCommand"
		setDrivenKeyItem;
	menuItem -divider true;

    menuItem -label (uiRes("m_setDrivenKeyWindow.kGoToPrev"))
		-command "goToDrivenKeyCallback -previous"
		previousDrivenKeyItem;

    menuItem -label (uiRes("m_setDrivenKeyWindow.kGoToNext"))
		-command "goToDrivenKeyCallback -next"
		nextDrivenKeyItem;
	setParent -menu ..;

 	menu -label (uiRes("m_setDrivenKeyWindow.kSelect"))  -tearOff true;
 	menuItem -label (uiRes("m_setDrivenKeyWindow.kDrivenItems"))  -command "selectDriven";
 	setParent -menu ..;

	//	Adds support for the Context Sensitive Help Menu.
	//
	addContextHelpProc "setDrivenWnd" "buildSetDrivenKeyContextHelpItems";

	doHelpMenu "setDrivenWnd" "setDrivenWnd";

	setParent -menu ..;

	formLayout setDrivenForm;
	formLayout objectsForm;
	frameLayout -label (uiRes("m_setDrivenKeyWindow.kDriver"))
		-borderVisible true -borderStyle "etchedIn"
		-collapse false -collapsable false
		-marginHeight 10 -marginWidth 10
		driverLayout;

	// Set to true to show the longName textScrollList *and*
	// the uiName textScrollList used to build up the
	// commands this window generates.  Normally, the user
	// will never see the longName list anymore (as this
	// functionality is provided by the uiName
	// textScrollList when it's in "Long Name" mode) but displaying
	// both listers could be useful for debugging.
	//
	int $debugMode = false;

	formLayout driverForm;
	textScrollList
		-allowMultiSelection false
		-selectCommand "updateChannels driverObjects driverChannelsLong driverChannelsUI;  selectListItems driverObjects;"
		driverObjects;
	textScrollList
		-manage $debugMode
		-allowMultiSelection false
		driverChannelsLong;
	textScrollList -selectCommand "updateKeyButton"
		-allowMultiSelection false
		driverChannelsUI;
	setParent ..;

	if( $debugMode ) {
		formLayout -edit
			-attachForm driverObjects top 0
			-attachForm driverObjects left 0
			-attachPosition driverObjects right 0 25
			-attachForm driverObjects bottom 0

			-attachForm driverChannelsLong top 0
			-attachControl driverChannelsLong left 0 driverObjects
			-attachControl driverChannelsUI left 0 driverChannelsLong

			-attachForm driverChannelsUI top 0
			-attachControl driverChannelsUI left 0 driverChannelsLong
			-attachForm driverChannelsUI right 0
			-attachForm driverChannelsUI bottom 0

			-attachForm driverChannelsLong bottom 0
			driverForm;
	} else {
		formLayout -edit
			-attachForm driverObjects top 0
			-attachForm driverObjects left 0
			-attachPosition driverObjects right 0 50
			-attachForm driverObjects bottom 0

			-attachForm driverChannelsUI top 0
			-attachControl driverChannelsUI left 0 driverObjects
			-attachForm driverChannelsUI right 0
			-attachForm driverChannelsUI bottom 0
			driverForm;
	}

	setParent ..;

	frameLayout -label (uiRes("m_setDrivenKeyWindow.kDriven"))
		-borderVisible true -borderStyle "etchedIn"
		-collapse false -collapsable false
		-marginHeight 10 -marginWidth 10
		drivenLayout;

	formLayout driverForm;
	textScrollList
		-allowMultiSelection true
		-selectCommand "updateChannels drivenObjects drivenChannelsLong drivenChannelsUI; selectListItems drivenObjects;"
		drivenObjects;
	textScrollList
		-manage $debugMode
		-allowMultiSelection true
		drivenChannelsLong;
	textScrollList -selectCommand "updateKeyButton"
		-allowMultiSelection true
		drivenChannelsUI;
	setParent ..;

	if( $debugMode ) {
		formLayout -edit
			-attachForm drivenObjects top 0
			-attachForm drivenObjects left 0
			-attachPosition drivenObjects right 0 25
			-attachForm drivenObjects bottom 0

			-attachForm drivenChannelsLong top 0
			-attachControl drivenChannelsLong left 0 drivenObjects
			-attachControl drivenChannelsUI left 0 drivenChannelsLong

			-attachForm drivenChannelsUI top 0
			-attachControl drivenChannelsUI left 0 drivenChannelsLong
			-attachForm drivenChannelsUI right 0
			-attachForm drivenChannelsUI bottom 0

			-attachForm drivenChannelsLong bottom 0
			driverForm;
	} else {
		formLayout -edit
			-attachForm drivenObjects top 0
			-attachForm drivenObjects left 0
			-attachPosition drivenObjects right 0 50
			-attachForm drivenObjects bottom 0

			-attachForm drivenChannelsUI top 0
			-attachControl drivenChannelsUI left 0 drivenObjects
			-attachForm drivenChannelsUI right 0
			-attachForm drivenChannelsUI bottom 0
			driverForm;
	}

	setParent ..;
	setParent ..;

	formLayout -edit
		-attachForm driverLayout top 2
		-attachForm driverLayout left 2
		-attachForm driverLayout right 2
		-attachPosition driverLayout bottom 2 50

		-attachControl drivenLayout top 2 driverLayout
		-attachForm drivenLayout left 2
		-attachForm drivenLayout right 2
		-attachForm drivenLayout bottom 2
		objectsForm;

	formLayout buttonForm;
	button -label (uiRes("m_setDrivenKeyWindow.kKeyButton"))
		-enable false
		-annotation (uiRes("m_setDrivenKeyWindow.kKeyAnnot"))
		-command "generateSetDrivenCommand" keyButton;
	button -label (uiRes("m_setDrivenKeyWindow.kLoadDriver"))
		-annotation (uiRes("m_setDrivenKeyWindow.kLoadDriverAnnot"))
		-command "updateSetDrivenWnd(\"driver\",\"\",{})" updateDriver;
	button -label (uiRes("m_setDrivenKeyWindow.kLoadDriven"))
		-annotation (uiRes("m_setDrivenKeyWindow.kLoadDrivenAnnot"))
		-command "updateSetDrivenWnd(\"driven\",\"\",{})" updateDriven;
    button -label (uiRes("m_setDrivenKeyWindow.kClose"))
          -command "window -edit -visible 0 setDrivenWnd"
          closeButton;

	setParent ..;

	formLayout -edit
		-attachForm keyButton left 2
		-attachControl keyButton right 2 updateDriver
		-attachForm keyButton top 5
		-attachForm keyButton bottom 5

		-attachPosition updateDriver left 5 25
		-attachPosition updateDriver right 1 50
		-attachForm updateDriver top 5
		-attachForm updateDriver bottom 5

		-attachPosition updateDriven left 1 50
		-attachPosition updateDriven right 5 75
		-attachForm updateDriven top 5
		-attachForm updateDriven bottom 5

		-attachForm    closeButton top 5
        -attachControl closeButton left 2 updateDriven
        -attachForm    closeButton right 2
        -attachForm    closeButton bottom 5
		buttonForm;


//##########################################################################
//
// sciloop
	sciCreateButtonForSetDrivenKeyWindow();

//##########################################################################


	setParent ..;

	formLayout -edit

//##########################################################################
//
// sciloop
//
		-attachForm "sciSetDrivenKeyRadioButtonForm" bottom 5
		-attachPosition "sciSetDrivenKeyRadioButtonForm" right 1 55

		-attachForm buttonForm bottom 45
		//-attachForm buttonForm bottom 5 // Maya default

//##########################################################################

		-attachForm buttonForm left 5
		-attachForm buttonForm right 5

		-attachForm objectsForm top 5
		-attachForm objectsForm left 5
		-attachForm objectsForm right 5
		-attachControl objectsForm bottom 5 buttonForm

		setDrivenForm;
}

global proc clearSDKwindow() {
	if( `window -exists setDrivenWnd` ) {
		updateSetDrivenWnd("driven","",{});
		updateSetDrivenWnd("driver","",{});
	}
}

global proc setDrivenKeyWindow(string $node, string $attr[])
{
	$driversAreGuides = 0;

	if( `window -exists setDrivenWnd` ) {
		showWindow setDrivenWnd;
	} else {
		// create the window
		//
		createSetDrivenWnd();

		scriptJob -protected
			-parent "setDrivenWnd"
			-conditionTrue deleteAllCondition clearSDKwindow;
	}

	updateSetDrivenWnd("driven",$node,$attr);
	loadCurrentDriver;
	showWindow setDrivenWnd;
}
